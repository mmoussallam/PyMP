

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Union of MDCT basis Classes documentation : &mdash; PyMP 1.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PyMP 1.0.1 documentation" href="index.html" />
    <link rel="prev" title="Classes Package Documentation:" href="classes.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes Package Documentation:"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyMP 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Union of MDCT basis Classes documentation :</a><ul>
<li><a class="reference internal" href="#classes-for-standard-algorithm">Classes for Standard Algorithm</a></li>
<li><a class="reference internal" href="#classes-for-random-matching-pursuit">Classes for Random Matching Pursuit</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="classes.html"
                        title="previous chapter">Classes Package Documentation:</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Mdct.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="union-of-mdct-basis-classes-documentation">
<h1>Union of MDCT basis Classes documentation :<a class="headerlink" href="#union-of-mdct-basis-classes-documentation" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><span class="target" id="module-PyMP.mdct"></span></div></blockquote>
<div class="section" id="classes-for-standard-algorithm">
<h2>Classes for Standard Algorithm<a class="headerlink" href="#classes-for-standard-algorithm" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><span class="target" id="module-PyMP.mdct.atom"></span><div class="section" id="module-mdct-atom">
<h3>Module mdct.atom<a class="headerlink" href="#module-mdct-atom" title="Permalink to this headline">¶</a></h3>
<p>This class inherits from <a class="reference internal" href="#PyMP.mdct.atom.Atom" title="PyMP.mdct.atom.Atom"><tt class="xref py py-class docutils literal"><span class="pre">Atom</span></tt></a> and is used to represent and manipulate MDCT atoms.
<a class="reference internal" href="#PyMP.mdct.atom.Atom" title="PyMP.mdct.atom.Atom"><tt class="xref py py-class docutils literal"><span class="pre">Atom</span></tt></a> Objects can either be constructed or recovered from Xml using <tt class="xref py py-func docutils literal"><span class="pre">fromXml()</span></tt></p>
<dl class="class">
<dt id="PyMP.mdct.atom.Atom">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.atom.</tt><tt class="descname">Atom</tt><big>(</big><em>scale=0</em>, <em>amp=0</em>, <em>timePos=0</em>, <em>freqBin=0</em>, <em>Fs=0</em>, <em>mdctCoeff=0</em><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>MDCT atom class : implement real domain MDCT atoms of scale defined by the atom length</p>
<p>An MDCT atom is defined for a length L, a frequency localization k and a frame parameter p by:</p>
<img src="_images/mathmpl/math-f017b011b8.png" class="center" /><p>Additionnal attributes are:</p>
<blockquote>
<div><ul class="simple">
<li><cite>freq_bin</cite> : MDCT frequency bin index (default is 0)</li>
<li><cite>frame</cite> : the frame index of the atom</li>
<li><cite>reduced_frequency</cite>: corresponding sampling frequency (default is 0)</li>
<li><cite>mdct_value</cite> : the atom mdct coefficient</li>
</ul>
</div></blockquote>
<p>Additionnal parameters for time-shifted atoms:</p>
<blockquote>
<div><ul class="simple">
<li><cite>time_shift</cite>: time shift in samples related to the closest MDCT grid index*</li>
<li><cite>proj_score</cite>: useful when atom is reprojected using say.. LOMP algorithm</li>
</ul>
</div></blockquote>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.atom.Atom.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>copycat routine</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.atom.Atom.get_tf_info">
<tt class="descname">get_tf_info</tt><big>(</big><em>Fs</em><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.get_tf_info" title="Permalink to this definition">¶</a></dt>
<dd><p>returns energy centroids and spread in the time frequency plane</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.atom.Atom.get_waveform">
<tt class="descname">get_waveform</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.get_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the atom waveform</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.atom.Atom.inner_prod">
<tt class="descname">inner_prod</tt><big>(</big><em>otherAtom</em><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.inner_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED returns the inner product between current atom and the other one
This method should be as fast as possible</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.atom.Atom.synthesize">
<tt class="descname">synthesize</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.synthesize" title="Permalink to this definition">¶</a></dt>
<dd><p>synthesizes the waveform
Specifies the amplitude, otherwise it will be initialiazed as unit-normed</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.atom.Atom.synthesize_ifft">
<tt class="descname">synthesize_ifft</tt><big>(</big><em>newValue=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.atom.Atom.synthesize_ifft" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED synthesis using Python fftw3 wrapper but no waveform server... a lot slower</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-PyMP.mdct.block"></span><div class="section" id="module-mdct-block">
<h3>Module mdct.block<a class="headerlink" href="#module-mdct-block" title="Permalink to this headline">¶</a></h3>
<p>This class inherits from <a class="reference internal" href="classes.html#PyMP.base.BaseBlock" title="PyMP.base.BaseBlock"><tt class="xref py py-class docutils literal"><span class="pre">BaseBlock</span></tt></a> and is used to represent and manipulate MDCT atoms.
<tt class="xref py py-class docutils literal"><span class="pre">mdct.Atom</span></tt> Objects can either be constructed or recovered from Xml using <tt class="xref py py-func docutils literal"><span class="pre">mdct.Atom.fromXml()</span></tt></p>
<p>MDCT Blocks are the objects encapsulating the actual atomic projections and the selection step of MP</p>
<dl class="docutils">
<dt>This module describes 3 kind of blocks:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><a class="reference internal" href="#PyMP.mdct.block.Block" title="PyMP.mdct.block.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a>  is a block based on the standard MDCT transform. Which means atoms localizations</dt>
<dd><p class="first last">are constrained by the scale of the transform
The atom selected is simple the one that maximizes the correlation with the residual
it is directly indexes by the max absolute value of the MDCT bin
No further optimization of the selected atom is performed</p>
</dd>
</dl>
</li>
<li><p class="first"><a class="reference internal" href="#PyMP.mdct.block.LOBlock" title="PyMP.mdct.block.LOBlock"><tt class="xref py py-class docutils literal"><span class="pre">LOBlock</span></tt></a>   is a block that performs a local optimization of the time localization of the selected atom</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-class docutils literal"><span class="pre">FullBlock</span></tt>  this block simulates a dictionary where atoms at all time localizations are available</dt>
<dd><p class="first last">This kind of dictionary can be thought of as a Toeplitz matrix
BEWARE: memory consumption and CPU load will be very high! only use with very small signals
(e.g. 1024 samples or so) Fairly intractable at higher dimensions</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="PyMP.mdct.block.Block">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.block.</tt><tt class="descname">Block</tt><big>(</big><em>length=0</em>, <em>resSignal=None</em>, <em>frameLen=0</em>, <em>useC=True</em>, <em>forceHF=False</em>, <em>debug_level=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a basic MDCT block. It handles a set of routines that allows greedy
decomposition algorithms (MP, OMP , GP ...) to iteratively project the ongoing residual
onto a specified MDCT base and to retrieve the maximum inner product</p>
<blockquote>
<div><dl class="docutils">
<dt>IMPORTANT: the computation of the inner products relies on a C-written module parallelProjections</dt>
<dd>that needs being compiled first on whatever your plateform.
Run the test file: parallelProjections/install_and_test.py in order to compile it
and perform some basic execution tests</dd>
</dl>
</div></blockquote>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.block.Block.compute_transform">
<tt class="descname">compute_transform</tt><big>(</big><em>startingFrame=1</em>, <em>endFrame=-1</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.compute_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>inner product computation through MDCT</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.block.Block.find_max">
<tt class="descname">find_max</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.find_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Search among the inner products the one that maximizes correlation
the best candidate for each frame is already stored in the best_score_tree</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.block.Block.get_max_atom">
<tt class="descname">get_max_atom</tt><big>(</big><em>HF=False</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.get_max_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>construct the atom that best correlates with the signal</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.block.Block.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mdct of the residual and instantiate various windows and twiddle coefficients</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.block.Block.synthesize_atom">
<tt class="descname">synthesize_atom</tt><big>(</big><em>value=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.synthesize_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>synthesizes the best atom through ifft computation (much faster than closed form)
New version uses the PyWinServer to serve waveforms</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.block.Block.update">
<tt class="descname">update</tt><big>(</big><em>new_res_signal</em>, <em>startFrameIdx=0</em>, <em>stopFrameIdx=-1</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.Block.update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the part of the residual that has been changed and update inner products</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyMP.mdct.block.LOBlock">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.block.</tt><tt class="descname">LOBlock</tt><big>(</big><em>length=0</em>, <em>resSignal=None</em>, <em>frameLen=0</em>, <em>tinvOptim=True</em>, <em>useC=True</em>, <em>forceHF=False</em><big>)</big><a class="headerlink" href="#PyMP.mdct.block.LOBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that inherit classic MDCT block class and deals with local optimization
This is the main class for differentiating LOMP from MP</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
</dd></dl>

</div>
<span class="target" id="module-PyMP.mdct.dico"></span><div class="section" id="module-mdct-dico">
<h3>Module mdct.dico<a class="headerlink" href="#module-mdct-dico" title="Permalink to this headline">¶</a></h3>
<p>This class inherits from <a class="reference internal" href="classes.html#PyMP.base.BaseDico" title="PyMP.base.BaseDico"><tt class="xref py py-class docutils literal"><span class="pre">BaseDico</span></tt></a> and is used to represent and manipulate multiscale MDCT dictionaries.
Dictionaries are mostly implemented as a collection of <tt class="xref py py-class docutils literal"><span class="pre">pymp_MDCTBlock</span></tt> of various kind, according to the
nature of pursuit that is seeked.</p>
<dl class="docutils">
<dt>This module describes 3 kind of blocks:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><a class="reference internal" href="#PyMP.mdct.dico.Dico" title="PyMP.mdct.dico.Dico"><tt class="xref py py-class docutils literal"><span class="pre">Dico</span></tt></a>  is a Dico based on the standard MDCT transform. Which means atoms localizations</dt>
<dd><p class="first last">are constrained by the scale of the transform
The atom selected is simple the one that maximizes the correlation with the residual
it is directly indexes by the max absolute value of the MDCT bin
No further optimization of the selected atom is performed</p>
</dd>
</dl>
</li>
<li><p class="first"><a class="reference internal" href="#PyMP.mdct.dico.LODico" title="PyMP.mdct.dico.LODico"><tt class="xref py py-class docutils literal"><span class="pre">LODico</span></tt></a>   is a dictionary that performs a local optimization of the time localization of the selected atom</p>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#PyMP.mdct.dico.FullDico" title="PyMP.mdct.dico.FullDico"><tt class="xref py py-class docutils literal"><span class="pre">FullDico</span></tt></a>  this object simulates a dictionary where atoms at all time localizations are available</dt>
<dd><p class="first last">This kind of dictionary can be thought of as a Toeplitz matrix
BEWARE: memory consumption and CPU load will be very high! only use with very small signals
(e.g. 1024 samples or so) Fairly intractable at higher dimensions</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="PyMP.mdct.dico.Dico">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.dico.</tt><tt class="descname">Dico</tt><big>(</big><em>sizes=</em><span class="optional">[</span><span class="optional">]</span>, <em>useC=True</em>, <em>forceHF=False</em>, <em>debug_level=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico" title="Permalink to this definition">¶</a></dt>
<dd><p>class to handle multiscale MDCT dictionaries using MDCT blocks</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.dico.Dico.compute_touched_zone">
<tt class="descname">compute_touched_zone</tt><big>(</big><em>previousBestAtom</em>, <em>panic=False</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.compute_touched_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>update zone computed from the previously selected atom</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.find_block_by_scale">
<tt class="descname">find_block_by_scale</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.find_block_by_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the block corresponding to the given size or None if not found</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.get_atom_key">
<tt class="descname">get_atom_key</tt><big>(</big><em>atom</em>, <em>sigLength</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.get_atom_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the atom index in the dictionary</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.get_projections">
<tt class="descname">get_projections</tt><big>(</big><em>indexes</em>, <em>sigLength</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.get_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>additional method provided for Gradient Pursuits
indexes formalism: key as in the py_pursuit_Approx Object :
int(block*self.length +  frame*float(atom.length /2) + atom.frequencyBin)</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.init_proj_matrix">
<tt class="descname">init_proj_matrix</tt><big>(</big><em>itNumbers</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.init_proj_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>method used for monitoring the projection along iterations
ONLY for DEV purposes</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.initialize">
<tt class="descname">initialize</tt><big>(</big><em>residual_signal</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the collection of blocks specified by the MDCT sizes</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.update">
<tt class="descname">update</tt><big>(</big><em>residualSignal</em>, <em>iteratioNumber=0</em>, <em>debug=0</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the projections in each block, only where it needs to be done as specified</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.Dico.update_proj_matrix">
<tt class="descname">update_proj_matrix</tt><big>(</big><em>projMatrix</em>, <em>iterationNumber</em>, <em>normedProj=False</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.Dico.update_proj_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>method used for monitoring the projection along iterations
ONLY for DEV purposes</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyMP.mdct.dico.LODico">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.dico.</tt><tt class="descname">LODico</tt><big>(</big><em>sizes=</em><span class="optional">[</span><span class="optional">]</span>, <em>hrsizes=None</em>, <em>useC=True</em>, <em>debug_level=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.LODico" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift invariant MDCT dictionary
Only difference is in the constructor and initialization: need to use LOBlocks</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.dico.LODico.get_projections">
<tt class="descname">get_projections</tt><big>(</big><em>indexes</em>, <em>sigLength</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.LODico.get_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>additional method provided for Gradient Pursuits
indexes formalism: key as in the py_pursuit_Approx Object :
int(block*self.length +  frame*float(atom.length /2) + atom.frequencyBin)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyMP.mdct.dico.FullDico">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.dico.</tt><tt class="descname">FullDico</tt><big>(</big><em>sizes=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.FullDico" title="Permalink to this definition">¶</a></dt>
<dd><p>This class handles blocks were MDCT products are computed for
each and every possible time localization. Therefore Iterations
are very slow but convergence should be optimum</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.dico.FullDico.init_proj_matrix">
<tt class="descname">init_proj_matrix</tt><big>(</big><em>itNumbers</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.FullDico.init_proj_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>method used for monitoring the projection along iterations</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.mdct.dico.FullDico.update_proj_matrix">
<tt class="descname">update_proj_matrix</tt><big>(</big><em>projMatrix</em>, <em>iterationNumber</em>, <em>normedProj=False</em><big>)</big><a class="headerlink" href="#PyMP.mdct.dico.FullDico.update_proj_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>method used for monitoring the projection along iterations</p>
</dd></dl>

</dd></dl>

</div>
</div></blockquote>
</div>
<div class="section" id="classes-for-random-matching-pursuit">
<h2>Classes for Random Matching Pursuit<a class="headerlink" href="#classes-for-random-matching-pursuit" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><span class="target" id="module-PyMP.mdct.rand.block"></span><dl class="class">
<dt id="PyMP.mdct.rand.block.SequenceBlock">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.rand.block.</tt><tt class="descname">SequenceBlock</tt><big>(</big><em>length=0</em>, <em>resSignal=None</em>, <em>frameLen=0</em>, <em>randomType='random'</em>, <em>nbSim=1</em>, <em>windowType=None</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.rand.block.SequenceBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>block implementing the Randomized Pursuit</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>sequence_type</cite>: str</td>
<td><dl class="first docutils">
<dt>The type of time-shift sequence, available choices are</dt>
<dd><em>scale</em>
<em>random</em>
<em>gaussian</em>
<em>binom</em>
<em>dicho</em>
<em>jump</em>
<em>binary</em></dd>
</dl>
<p class="last">default is <em>random</em> which use a uniform pseudo-random generator</p>
</td>
</tr>
<tr class="row-even"><td><cite>shift_list</cite>: array-like</td>
<td>The actual sequence of subdictionary time-shifts</td>
</tr>
<tr class="row-odd"><td><cite>current_shift</cite>: int</td>
<td>The current time-shift</td>
</tr>
<tr class="row-even"><td><cite>nbSim</cite>: int</td>
<td>Number of consecutive iterations with the same time-shift (default is 1)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="PyMP.mdct.rand.block.SequenceBlock.update">
<tt class="descname">update</tt><big>(</big><em>new_res_signal</em>, <em>startFrameIdx=0</em>, <em>stopFrameIdx=-1</em>, <em>iteration_number=0</em><big>)</big><a class="headerlink" href="#PyMP.mdct.rand.block.SequenceBlock.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as superclass except that at each update, one need to pick a time shift from the sequence</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-PyMP.mdct.rand.dico"></span><div class="section" id="module-pymp-mdct-rand-dico">
<h3>Module PyMP.mdct.rand.dico<a class="headerlink" href="#module-pymp-mdct-rand-dico" title="Permalink to this headline">¶</a></h3>
<p>This file handle dctionaries that are used in Randomized Matching Pursuits
see [1] for details.</p>
<p>[1] M. Moussallam, L. Daudet, et G. Richard,
&#8220;Matching Pursuits with Random Sequential Subdictionaries&#8221;
Signal Processing, vol. 92, pp. 2532-2544 2012.</p>
<dl class="class">
<dt id="PyMP.mdct.rand.dico.SequenceDico">
<em class="property">class </em><tt class="descclassname">PyMP.mdct.rand.dico.</tt><tt class="descname">SequenceDico</tt><big>(</big><em>sizes=</em><span class="optional">[</span><span class="optional">]</span>, <em>seq_type='random'</em>, <em>nbSame=1</em>, <em>windowType=None</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#PyMP.mdct.rand.dico.SequenceDico" title="Permalink to this definition">¶</a></dt>
<dd><p>This dictionary implements a sequence of subdictionaries that are shifted in time at each iteration in a pre-defined manner
the shifts are controlled by the different blocks.</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
</dd></dl>

</div>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes Package Documentation:"
             >previous</a> |</li>
        <li><a href="index.html">PyMP 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Manuel Moussallam.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>