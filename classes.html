

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classes Package Documentation: &mdash; PyMP 0.9.1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PyMP 0.9.1 documentation" href="index.html" />
    <link rel="next" title="Union of MDCT basis Classes documentation :" href="Mdct.html" />
    <link rel="prev" title="MP routines Documentation" href="MP.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Mdct.html" title="Union of MDCT basis Classes documentation :"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MP.html" title="MP routines Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyMP 0.9.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Classes Package Documentation:</a><ul>
<li><a class="reference internal" href="#signal-and-approximation-handles">Signal and Approximation Handles</a></li>
<li><a class="reference internal" href="#abstract-mp-classes">Abstract MP classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="MP.html"
                        title="previous chapter">MP routines Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Mdct.html"
                        title="next chapter">Union of MDCT basis Classes documentation :</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/classes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="classes-package-documentation">
<h1>Classes Package Documentation:<a class="headerlink" href="#classes-package-documentation" title="Permalink to this headline">¶</a></h1>
<p>The root PyMP package contains all basic pymp objects such as <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a> ,  <a class="reference internal" href="#PyMP.approx.Approx" title="PyMP.approx.Approx"><tt class="xref py py-class docutils literal"><span class="pre">Approx</span></tt></a> and abstract classes <a class="reference internal" href="Mdct.html#PyMP.mdct.dico.Dico" title="PyMP.mdct.dico.Dico"><tt class="xref py py-class docutils literal"><span class="pre">Dico</span></tt></a>,
<a class="reference internal" href="Mdct.html#PyMP.mdct.atom.Atom" title="PyMP.mdct.atom.Atom"><tt class="xref py py-class docutils literal"><span class="pre">Atom</span></tt></a> and <a class="reference internal" href="Mdct.html#PyMP.mdct.block.Block" title="PyMP.mdct.block.Block"><tt class="xref py py-class docutils literal"><span class="pre">Block</span></tt></a></p>
<div class="section" id="signal-and-approximation-handles">
<h2>Signal and Approximation Handles<a class="headerlink" href="#signal-and-approximation-handles" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><span class="target" id="module-PyMP.signals"></span><div class="section" id="module-signals">
<h3>Module signals<a class="headerlink" href="#module-signals" title="Permalink to this headline">¶</a></h3>
<p>The main class is <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a>, it can be instantiated from a numpy array
using the main constructor (multichannel is allowed).</p>
<p>It can also be created from a file on the disk using the path as argument
in the constructor</p>
<p>Longer Signals are handled with <a class="reference internal" href="#PyMP.signals.LongSignal" title="PyMP.signals.LongSignal"><tt class="xref py py-class docutils literal"><span class="pre">LongSignal</span></tt></a> objects.</p>
<dl class="class">
<dt id="PyMP.signals.Signal">
<em class="property">class </em><tt class="descclassname">PyMP.signals.</tt><tt class="descname">Signal</tt><big>(</big><em>data=</em><span class="optional">[</span><span class="optional">]</span>, <em>Fs=0</em>, <em>normalize=False</em>, <em>mono=False</em>, <em>debug_level=None</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal" title="Permalink to this definition">¶</a></dt>
<dd><p>This file defines the main class handling audio signal in the Pymp Framework.</p>
<p>A Signal is fairly a numpy array (called data) and a collection of attributes.
Longer signals should not be loaded in memory. the <cite>LongSignal</cite> class allows
to define this kind of signal, and slice it in frames overlapping or not.</p>
<p>Attributes:</p>
<blockquote>
<div><p><cite>channel_num</cite>:The number of channel</p>
<p><cite>length</cite>:                The length in samples (integer) of the signal (total dimension of the numpy array is channel_num x length)</p>
<p><cite>samplingFrequency</cite>:     The sampling frequency</p>
<p><cite>location</cite>:              (optional) Where the original file is located on the disk</p>
<p><cite>sample_width</cite> :          Various bit format exist for wav file, this allows to handle it</p>
<p><cite>is_normalized</cite> :         A boolean telling is the numpy array has been normalized (which here means its values are between -1 and 1)</p>
<p><cite>energy</cite>:                The energy (<img src="_images/mathmpl/math-77395d18e2.png" style="position: relative; bottom: -21px"/>) of the array</p>
</div></blockquote>
<p>Standard methods to manipulate the signal are:</p>
<blockquote>
<div><p><a class="reference internal" href="#PyMP.signals.Signal.normalize" title="PyMP.signals.Signal.normalize"><tt class="xref py py-func docutils literal"><span class="pre">normalize()</span></tt></a> : makes sure all values of the array are between -1 and 1</p>
<p><a class="reference internal" href="#PyMP.signals.Signal.plot" title="PyMP.signals.Signal.plot"><tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt></a>: Plot using matlplotlib</p>
<p><a class="reference internal" href="#PyMP.signals.Signal.crop" title="PyMP.signals.Signal.crop"><tt class="xref py py-func docutils literal"><span class="pre">crop()</span></tt></a> : crop</p>
<p><a class="reference internal" href="#PyMP.signals.Signal.pad" title="PyMP.signals.Signal.pad"><tt class="xref py py-func docutils literal"><span class="pre">pad()</span></tt></a>:  with zeroes</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">copy()</span></tt>:</p>
<p><a class="reference internal" href="#PyMP.signals.Signal.downsample" title="PyMP.signals.Signal.downsample"><tt class="xref py py-func docutils literal"><span class="pre">downsample()</span></tt></a>:</p>
</div></blockquote>
<p>For use in the PyMP framework, other methods need to be defined:</p>
<blockquote>
<div><p><a class="reference internal" href="#PyMP.signals.Signal.add" title="PyMP.signals.Signal.add"><tt class="xref py py-func docutils literal"><span class="pre">add()</span></tt></a>:             adds an atom waveform to the current signal and updates energy</p>
<p><a class="reference internal" href="#PyMP.signals.Signal.subtract" title="PyMP.signals.Signal.subtract"><tt class="xref py py-func docutils literal"><span class="pre">subtract()</span></tt></a>:        the opposite operation</p>
</div></blockquote>
<p>Output Methods: <a class="reference internal" href="#PyMP.signals.Signal.write" title="PyMP.signals.Signal.write"><tt class="xref py py-func docutils literal"><span class="pre">write()</span></tt></a></p>
<dl class="method">
<dt id="PyMP.signals.Signal.add">
<tt class="descname">add</tt><big>(</big><em>atom</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.add" title="Permalink to this definition">¶</a></dt>
<dd><p>adds the contribution of the atom at the position specified by the atom.timeLocalization property</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.crop">
<tt class="descname">crop</tt><big>(</big><em>startIndex=0</em>, <em>stopIndex=None</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>cropping routine, usage is quite obvious</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.depad">
<tt class="descname">depad</tt><big>(</big><em>zero_pad</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.depad" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove zeroes from the edges WARNING: no test on the deleted data: make sure these are zeroes!</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.downsample">
<tt class="descname">downsample</tt><big>(</big><em>newFs</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>downsampling the signal by taking only a portion of the data</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.normalize">
<tt class="descname">normalize</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>makes sure all values of the array are between -1 and 1</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.pad">
<tt class="descname">pad</tt><big>(</big><em>zero_pad</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad edges with zeroes</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.plot">
<tt class="descname">plot</tt><big>(</big><em>pltStr='b-'</em>, <em>legend=None</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED plot the array using matplotlib</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.subtract">
<tt class="descname">subtract</tt><big>(</big><em>atom</em>, <em>debug=0</em>, <em>preventEnergyIncrease=True</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts the atom waveform from the signal, at the position specified by the atom.timeLocalization property
if preventEnergyIncrease is True, an error will be raised if subtracting the atom increases the signal&#8217;s energy</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.wigner_plot">
<tt class="descname">wigner_plot</tt><big>(</big><em>window=True</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.wigner_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the wigner ville distribution and plots it
WARNING: not sufficiently tested!</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.signals.Signal.write">
<tt class="descname">write</tt><big>(</big><em>fileOutputPath</em>, <em>pad=0</em><big>)</big><a class="headerlink" href="#PyMP.signals.Signal.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the current signal at the specified location in wav format</p>
<p>This is done using the wave python library</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyMP.signals.LongSignal">
<em class="property">class </em><tt class="descclassname">PyMP.signals.</tt><tt class="descname">LongSignal</tt><big>(</big><em>filepath</em>, <em>frameSize=49152</em>, <em>frameDuration=None</em>, <em>forceMono=False</em>, <em>Noverlap=0</em><big>)</big><a class="headerlink" href="#PyMP.signals.LongSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>A class handling long audio signals</p>
<blockquote>
<div><p>Subclass of <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a> where the data is not loaded at once for memory consumptions purposes
Instead, the data is sliced in frames that can be loaded later individually. very useful to
process large files such as audio archives</p>
<p>Attributes:</p>
<blockquote>
<div><p><cite>filepath</cite>:    The path to the audio file</p>
<p><cite>frameSize</cite>:   In samples, default is 16384*3</p>
<p><cite>frameDuration</cite>:  Alternative to frameSize, specify directly a frame duration in seconds (Defult is None)</p>
<p><cite>forceMono</cite>:      Only load the left (first) channel (default is False)</p>
<p><cite>Noverlap</cite> :      overlap (as a ratio r such that <img src="_images/mathmpl/math-04e238ee3c.png" style="position: relative; bottom: -6px"/>)</p>
</div></blockquote>
</div></blockquote>
<p>Standard methods to manipulate the signal are:</p>
<blockquote>
<div><a class="reference internal" href="#PyMP.signals.LongSignal.get_sub_signal" title="PyMP.signals.LongSignal.get_sub_signal"><tt class="xref py py-func docutils literal"><span class="pre">get_sub_signal()</span></tt></a> : Loads a subSignal</div></blockquote>
<dl class="method">
<dt id="PyMP.signals.LongSignal.get_sub_signal">
<tt class="descname">get_sub_signal</tt><big>(</big><em>startSegment</em>, <em>segmentNumber</em>, <em>mono=False</em>, <em>normalize=False</em>, <em>channel=0</em>, <em>padSignal=0</em><big>)</big><a class="headerlink" href="#PyMP.signals.LongSignal.get_sub_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to actually read from the buffer and return a smaller signal instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body">a <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a> object</td>
</tr>
<tr class="field-even field"><th class="field-name">Example :</th><td class="field-body">longSig = LongSignal(<strong>myLongSigFilePath</strong>, frameDuration=5) # Initialize long signal
subSig = longSig.get_sub_signal(0,10) # Loads the first 50 seconds of data</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-PyMP.approx"></span><div class="section" id="module-approx">
<h3>Module approx<a class="headerlink" href="#module-approx" title="Permalink to this headline">¶</a></h3>
<p>The main class is <a class="reference internal" href="#PyMP.approx.Approx" title="PyMP.approx.Approx"><tt class="xref py py-class docutils literal"><span class="pre">Approx</span></tt></a></p>
<dl class="class">
<dt id="PyMP.approx.Approx">
<em class="property">class </em><tt class="descclassname">PyMP.approx.</tt><tt class="descname">Approx</tt><big>(</big><em>dico=None</em>, <em>atoms=</em><span class="optional">[</span><span class="optional">]</span>, <em>originalSignal=None</em>, <em>length=0</em>, <em>Fs=0</em>, <em>debug_level=None</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx" title="Permalink to this definition">¶</a></dt>
<dd><p>The approx class encapsulate the approximation that is iteratively being constructed by a greed algorithm</p>
<p>This object handles MP constructed approximations
The approx object is quite similarr in nature to the MPTK [1] Book object but allows
further manipulations in python such as plotting the time frequency distribution of atoms</p>
<p>The object has following attributes:
Attributes:</p>
<blockquote>
<div><ul class="simple">
<li><cite>dico</cite>     : the dictionary (as a <a class="reference internal" href="#PyMP.base.BaseDico" title="PyMP.base.BaseDico"><tt class="xref py py-class docutils literal"><span class="pre">BaseDico</span></tt></a> object) from which it has been constructed</li>
<li><cite>atoms</cite>    : a list of <a class="reference internal" href="Mdct.html#PyMP.mdct.atom.Atom" title="PyMP.mdct.atom.Atom"><tt class="xref py py-class docutils literal"><span class="pre">Atom</span></tt></a> objets</li>
<li><cite>atom_number</cite>    : the length of the atoms list</li>
<li><cite>srr</cite>           : the Signal to Residual Ratio achieved by the approximation</li>
<li><cite>original_signal</cite>    : a <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a> object that is the original signal</li>
<li><cite>length</cite>        : Length in samples of the time signal, same as the one of <cite>original_signal</cite></li>
<li><cite>recomposed_signal</cite>   : a <a class="reference internal" href="#PyMP.signals.Signal" title="PyMP.signals.Signal"><tt class="xref py py-class docutils literal"><span class="pre">Signal</span></tt></a> objet for the reconstructed signal (as the weighted sum of atoms specified in the atoms list)</li>
</ul>
</div></blockquote>
<p>An approximant can be manipulated in various ways. Obviously atoms can be edited by several methods among which
<a class="reference internal" href="#PyMP.approx.Approx.add" title="PyMP.approx.Approx.add"><tt class="xref py py-func docutils literal"><span class="pre">add()</span></tt></a> ,  <a class="reference internal" href="#PyMP.approx.Approx.remove" title="PyMP.approx.Approx.remove"><tt class="xref py py-func docutils literal"><span class="pre">remove()</span></tt></a>  and <tt class="xref py py-func docutils literal"><span class="pre">filterAtom()</span></tt></p>
<p>Measure of distorsion can be estimated by the method <a class="reference internal" href="#PyMP.approx.Approx.compute_srr" title="PyMP.approx.Approx.compute_srr"><tt class="xref py py-func docutils literal"><span class="pre">compute_srr()</span></tt></a></p>
<p>Approx objets can be exported in various formats using
<a class="reference internal" href="#PyMP.approx.Approx.to_dico" title="PyMP.approx.Approx.to_dico"><tt class="xref py py-func docutils literal"><span class="pre">to_dico()</span></tt></a> ,
<a class="reference internal" href="#PyMP.approx.Approx.to_sparse_array" title="PyMP.approx.Approx.to_sparse_array"><tt class="xref py py-func docutils literal"><span class="pre">to_sparse_array()</span></tt></a> ,
<a class="reference internal" href="#PyMP.approx.Approx.to_array" title="PyMP.approx.Approx.to_array"><tt class="xref py py-func docutils literal"><span class="pre">to_array()</span></tt></a> ,
<a class="reference internal" href="#PyMP.approx.Approx.write_to_xml" title="PyMP.approx.Approx.write_to_xml"><tt class="xref py py-func docutils literal"><span class="pre">write_to_xml()</span></tt></a> ,
<tt class="xref py py-func docutils literal"><span class="pre">dumpToDisk()</span></tt> ,</p>
<p>and reversely can be recovered from these formats</p>
<p>A useful plotting routine, <a class="reference internal" href="#PyMP.approx.Approx.plot_tf" title="PyMP.approx.Approx.plot_tf"><tt class="xref py py-func docutils literal"><span class="pre">plot_tf()</span></tt></a> is provided to visualize atom distribution in the time frequency plane
Also an experimental 3D plot taking the atom iteration number as a depth parameter
<a class="reference internal" href="#PyMP.approx.Approx.plot_3d" title="PyMP.approx.Approx.plot_3d"><tt class="xref py py-func docutils literal"><span class="pre">plot_3d()</span></tt></a></p>
<dl class="method">
<dt id="PyMP.approx.Approx.add">
<tt class="descname">add</tt><big>(</big><em>newAtom</em>, <em>clean=False</em>, <em>noWf=False</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.add" title="Permalink to this definition">¶</a></dt>
<dd><p>this function adds an atom to the collection and updates the internal signal approximant</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.compute_srr">
<tt class="descname">compute_srr</tt><big>(</big><em>residual=None</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.compute_srr" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to compute approximation Signal To Residual ratio so far using:</p>
<blockquote>
<div></div></blockquote>
<p>rac{|   ilde{x} |^2}{|        ilde{x} - x |^2}</p>
<blockquote>
<div>where :math:`       ilde{x}` is the reconstructed signal and <img src="_images/mathmpl/math-4e155c67a6.png" style="position: relative; bottom: -3px"/> the original</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.filter_atoms">
<tt class="descname">filter_atoms</tt><big>(</big><em>mdctSize=0</em>, <em>posInterv=None</em>, <em>freqInterv=None</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.filter_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the atom list by the given criterion, returns an new approximant object</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.plot_3d">
<tt class="descname">plot_3d</tt><big>(</big><em>itStep</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.plot_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a 3D Time-Frequency plot with various steps NOT WORKING below 0.99
EXPERIMENTAL</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.plot_tf">
<tt class="descname">plot_tf</tt><big>(</big><em>labelX=True</em>, <em>labelY=True</em>, <em>fontsize=12</em>, <em>ylim=None</em>, <em>patchColor=None</em>, <em>labelColor=None</em>, <em>multicolor=False</em>, <em>axes=None</em>, <em>maxAtoms=None</em>, <em>recenter=None</em>, <em>keepValues=False</em>, <em>french=False</em>, <em>Alpha=False</em>, <em>logF=False</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.plot_tf" title="Permalink to this definition">¶</a></dt>
<dd><p>A time Frequency plot routine using Matplotlib</p>
<p>each atom of the approx is plotted in a time-frequency plane with a gray scale for amplitudes
Many options are available:</p>
<ul class="simple">
<li>labelX     : whether or not to add the Time label on the X axis</li>
<li>labelY     : whether or not to add the Frequency label on the Y axis</li>
<li>fontsize    : the label fontSize</li>
<li>ylim        : the frequency range of the plot</li>
<li>patchColor    : specify a single color for all atoms</li>
<li>maxAtoms    : specify a maximum number of atom to take into account. Usually atoms are ordered by decreasing amplitude due to MP rules, meaning only the most salient atoms will be plotted</li>
<li>recenter    : a couple of values to offset the time and frequency localization of atoms</li>
<li>keepValues    : use atom Amplitudes for atom colorations</li>
<li>french    : all labels in french</li>
<li>Alpha     : use transparency</li>
<li>logF        : frequency axis in logarithmic scale</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.remove">
<tt class="descname">remove</tt><big>(</big><em>atom</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>We need a routine to remove an atom , by default the last atom is removed</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.synthesize">
<tt class="descname">synthesize</tt><big>(</big><em>method=0</em>, <em>forceReSynthesis=True</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.synthesize" title="Permalink to this definition">¶</a></dt>
<dd><p>function that will synthesise the approximant using the list of atoms
this is mostly DEPRECATED</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.to_array">
<tt class="descname">to_array</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the approximant as an array object , key is the index of the atom and value is its amplitude</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.to_dico">
<tt class="descname">to_dico</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.to_dico" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the approximant as a sparse dictionary object ,
key is the index of the atom and values are atom objects</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.to_sparse_array">
<tt class="descname">to_sparse_array</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.to_sparse_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the approximant as a sparse dictionary object , key is the index of the atom and value is its amplitude</p>
</dd></dl>

<dl class="method">
<dt id="PyMP.approx.Approx.write_to_xml">
<tt class="descname">write_to_xml</tt><big>(</big><em>fname</em>, <em>output_path='./'</em><big>)</big><a class="headerlink" href="#PyMP.approx.Approx.write_to_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the atoms using an XML formalism to the designated output file</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="PyMP.approx.fusion_approxs">
<tt class="descclassname">PyMP.approx.</tt><tt class="descname">fusion_approxs</tt><big>(</big><em>approxCollection</em>, <em>unPad=True</em><big>)</big><a class="headerlink" href="#PyMP.approx.fusion_approxs" title="Permalink to this definition">¶</a></dt>
<dd><p>fusion a collection of frame by frame approximation.
The collection is assumed to be temporally ordered</p>
</dd></dl>

<dl class="function">
<dt id="PyMP.approx.read_from_mat_struct">
<tt class="descclassname">PyMP.approx.</tt><tt class="descname">read_from_mat_struct</tt><big>(</big><em>matl_struct</em><big>)</big><a class="headerlink" href="#PyMP.approx.read_from_mat_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the python object from a saved version in matlab format
This is useful if you saved a py_pursuit_approx object using the scipy.io.savemat
routine and you loaded it back using scipy.io.loadmat</p>
</dd></dl>

<dl class="function">
<dt id="PyMP.approx.read_from_xml">
<tt class="descclassname">PyMP.approx.</tt><tt class="descname">read_from_xml</tt><big>(</big><em>InputXmlFilePath</em>, <em>xmlDoc=None</em>, <em>buildSignal=True</em><big>)</big><a class="headerlink" href="#PyMP.approx.read_from_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>reads an xml document and create the corresponding Approx object
WARNING this method is only designed for MDCT pursuits for now</p>
</dd></dl>

</div>
</div></blockquote>
</div>
<div class="section" id="abstract-mp-classes">
<h2>Abstract MP classes<a class="headerlink" href="#abstract-mp-classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><span class="target" id="module-PyMP.base"></span><dl class="class">
<dt id="PyMP.base.BaseAtom">
<em class="property">class </em><tt class="descclassname">PyMP.base.</tt><tt class="descname">BaseAtom</tt><a class="headerlink" href="#PyMP.base.BaseAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract Atom class interface:</p>
<p>To implement a new type of atom, you must derive from this class.</p>
<p>Attributes:</p>
<blockquote>
<div><ul class="simple">
<li><cite>nature</cite>: A string describing the atom type (e.g MDCT, MCLT , GaborReal) default is MDCT</li>
<li><a href="#id1"><span class="problematic" id="id2">`</span></a>length: Sample length of the atom (default is 0)</li>
<li><cite>timePosition</cite>: The index of the first atom sample in a signal</li>
<li><cite>waveform</cite>: a numpy array that will contain the atom waveform</li>
<li><cite>amplitude</cite>: the atom amplitude</li>
<li><cite>fs</cite>: the atom sampling frequency</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="PyMP.base.BaseDico">
<em class="property">class </em><tt class="descclassname">PyMP.base.</tt><tt class="descname">BaseDico</tt><a class="headerlink" href="#PyMP.base.BaseDico" title="Permalink to this definition">¶</a></dt>
<dd><p>This class creates an interface that any type of dictionary should reproduce
in order to be used correclty by Pursuit algorithm in this framework:</p>
<blockquote>
<div><ul>
<li><p class="first"><cite>sizes</cite>: a list of scales</p>
</li>
<li><dl class="first docutils">
<dt><cite>blocks</cite>: a list of blocks that handles the projection of a residual signal along with</dt>
<dd><p class="first last">the selection of a projection maximum given a transform and a criteria</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="PyMP.base.BaseDico.get_pad">
<tt class="descname">get_pad</tt><big>(</big><big>)</big><a class="headerlink" href="#PyMP.base.BaseDico.get_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>the amount of zeroes that need to be added on the sides</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="PyMP.base.BaseBlock">
<em class="property">class </em><tt class="descclassname">PyMP.base.</tt><tt class="descname">BaseBlock</tt><a class="headerlink" href="#PyMP.base.BaseBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>A block is an instance handling projections for Matching Pursuit.</p>
<dl class="docutils">
<dt>Mandatory fields:</dt>
<dd><ul class="first last simple">
<li>type : the type of dictionary (e.g  Gabor , MDCT , Haar ...)</li>
<li>scale : the scale of the block</li>
<li>residualSignal : a py_pursuit_Signal instance that describes the current residual</li>
</ul>
</dd>
<dt>Mandatory methods</dt>
<dd><ul class="first last simple">
<li>update :  updates the inner products table</li>
<li>getMaximum : retrieve the maximum absolute value of inner products</li>
<li>getMaxAtom : return a corresponding Atom instance</li>
</ul>
</dd>
</dl>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Mdct.html" title="Union of MDCT basis Classes documentation :"
             >next</a> |</li>
        <li class="right" >
          <a href="MP.html" title="MP routines Documentation"
             >previous</a> |</li>
        <li><a href="index.html">PyMP 0.9.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Manuel Moussallam.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>